{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.regexp.to-string.js","webpack:///./node_modules/core-js/internals/is-regexp.js","webpack:///./node_modules/core-js/modules/es.regexp.constructor.js","webpack:///./node_modules/core-js/internals/inherit-if-required.js","webpack:///./src/views/RegisterForm.vue","webpack:///./node_modules/vue-demi/lib/index.esm.js","webpack:///./node_modules/@vuelidate/core/dist/index.esm.js","webpack:///./node_modules/@vuelidate/validators/dist/index.esm.js","webpack:///./src/views/RegisterForm.vue?8ab0"],"names":["redefine","anObject","fails","flags","TO_STRING","RegExpPrototype","RegExp","prototype","nativeToString","NOT_GENERIC","call","source","INCORRECT_NAME","name","R","this","p","String","rf","f","undefined","unsafe","isObject","classof","wellKnownSymbol","MATCH","module","exports","it","isRegExp","DESCRIPTORS","global","isForced","inheritIfRequired","defineProperty","getOwnPropertyNames","getFlags","stickyHelpers","setInternalState","set","setSpecies","NativeRegExp","re1","re2","CORRECT_NEW","UNSUPPORTED_Y","FORCED","RegExpWrapper","pattern","sticky","thisIsRegExp","patternIsRegExp","flagsAreUndefined","constructor","indexOf","replace","result","proxy","key","configurable","get","keys","index","length","setPrototypeOf","$this","dummy","Wrapper","NewTarget","NewTargetPrototype","class","tabindex","id","for","toggleModal","open","submitCreds","novalidate","isFree","isApiCall","checkUsername","type","username","email","v$","$invalid","password","minLength","Cpassword","to","isLoading","isVue3","_typeof","obj","Symbol","iterator","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","descriptor","enumerable","writable","Object","_createClass","protoProps","staticProps","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","_arr","_n","_d","_e","_s","_i","next","done","push","value","err","o","minLen","n","toString","slice","test","len","arr2","unwrap","val","unwrapObj","ignoreKeys","arguments","reduce","k","includes","isFunction","isProxy","_call","body","then","direct","Promise","resolve","e","reject","ROOT_PATH","_async","args","apply","sortValidations","validationsRaw","validations","validationKeys","rules","nestedValidators","config","forEach","v","$validator","startsWith","callRule","rule","normalizeValidatorResponse","$valid","createAsyncResult","model","$pending","$dirty","_ref","$response","$lazy","$pendingCounter","$unwatch","_ref2","ruleResult","_ref3","data","error","immediate","deep","createValidatorResult","$params","_createAsyncResult","message","$message","$model","createValidationResults","resultsCache","path","ruleKeys","cachedResult","$partial","$path","$touch","$reset","ruleKey","some","$error","$silentErrors","filter","map","res","$propertyPath","$property","$errors","collectNestedValidationResults","nestedState","nestedValidationKeys","results","nestedKey","setValidations","state","parentKey","globalConfig","createMetaFields","nestedResults","childResults","allResults","allRes","concat","values","every","r","modelErrors","nestedErrors","errors","$anyDirty","nr","_ref4","_ref4$globalConfig","_sortValidations","mergedConfig","assign","s","_createMetaFields","$autoDirty","autoDirtyPath","cachedAutoDirty","flush","$validate","unwatch","$getResultsForChild","ResultsStorage","storage","Map","storedRules","storedRulesKeys","newRulesKeys","hasAllValidators","paramKey","storedRuleResultPair","isValidCache","checkRulesValidity","VuelidateInjectChildResults","VuelidateRemoveChildResults","CollectFlag","COLLECT_ALL","COLLECT_NONE","nestedValidations","$scope","childResultsRaw","childResultsKeys","injectChildResultsIntoParent","$registerAs","childScope","$stopPropagation","removeChildResultsFromParent","childKey","sendValidationResultsToParent","removeValidationResultsFromParent","useVuelidate","_globalConfig","_globalConfig$$scope","componentOptions","$options","uid","_uid","validationResults","ComputedProxyFactory","Proxy","prop","receiver","validationsConfig","validationsWatchTarget","newValidationRules","normalizeValidatorObject","validator","withParams","Error","validatorObj","withMessage","Date","isNaN","getTime","_","regex","expr","emailRegex","email$1","minLength$1","min","required","trim","required$1","sameAs","equalTo","sameAs$1","otherName","urlRegex","regExp","isValid","components","BaseButton","computed","methods","$store","dispatch","success","showNotification","catch","finally","$router","response","status","mounted","window","googleUser","gapi","load","auth2","init","client_id","cookiepolicy","googleBtn","document","getElementById","attachClickHandler","token","getAuthResponse","id_token","render"],"mappings":"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","file":"js/register.793b8617.js","sourcesContent":["'use strict';\nvar redefine = require('../internals/redefine');\nvar anObject = require('../internals/an-object');\nvar fails = require('../internals/fails');\nvar flags = require('../internals/regexp-flags');\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar nativeToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = nativeToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  redefine(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var p = String(R.source);\n    var rf = R.flags;\n    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);\n    return '/' + p + '/' + f;\n  }, { unsafe: true });\n}\n","var isObject = require('../internals/is-object');\nvar classof = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar isForced = require('../internals/is-forced');\nvar inheritIfRequired = require('../internals/inherit-if-required');\nvar defineProperty = require('../internals/object-define-property').f;\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\nvar isRegExp = require('../internals/is-regexp');\nvar getFlags = require('../internals/regexp-flags');\nvar stickyHelpers = require('../internals/regexp-sticky-helpers');\nvar redefine = require('../internals/redefine');\nvar fails = require('../internals/fails');\nvar setInternalState = require('../internals/internal-state').set;\nvar setSpecies = require('../internals/set-species');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\nvar NativeRegExp = global.RegExp;\nvar RegExpPrototype = NativeRegExp.prototype;\nvar re1 = /a/g;\nvar re2 = /a/g;\n\n// \"new\" should create a new object, old webkit bug\nvar CORRECT_NEW = new NativeRegExp(re1) !== re1;\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\n\nvar FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {\n  re2[MATCH] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';\n})));\n\n// `RegExp` constructor\n// https://tc39.es/ecma262/#sec-regexp-constructor\nif (FORCED) {\n  var RegExpWrapper = function RegExp(pattern, flags) {\n    var thisIsRegExp = this instanceof RegExpWrapper;\n    var patternIsRegExp = isRegExp(pattern);\n    var flagsAreUndefined = flags === undefined;\n    var sticky;\n\n    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {\n      return pattern;\n    }\n\n    if (CORRECT_NEW) {\n      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;\n    } else if (pattern instanceof RegExpWrapper) {\n      if (flagsAreUndefined) flags = getFlags.call(pattern);\n      pattern = pattern.source;\n    }\n\n    if (UNSUPPORTED_Y) {\n      sticky = !!flags && flags.indexOf('y') > -1;\n      if (sticky) flags = flags.replace(/y/g, '');\n    }\n\n    var result = inheritIfRequired(\n      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),\n      thisIsRegExp ? this : RegExpPrototype,\n      RegExpWrapper\n    );\n\n    if (UNSUPPORTED_Y && sticky) setInternalState(result, { sticky: sticky });\n\n    return result;\n  };\n  var proxy = function (key) {\n    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {\n      configurable: true,\n      get: function () { return NativeRegExp[key]; },\n      set: function (it) { NativeRegExp[key] = it; }\n    });\n  };\n  var keys = getOwnPropertyNames(NativeRegExp);\n  var index = 0;\n  while (keys.length > index) proxy(keys[index++]);\n  RegExpPrototype.constructor = RegExpWrapper;\n  RegExpWrapper.prototype = RegExpPrototype;\n  redefine(global, 'RegExp', RegExpWrapper);\n}\n\n// https://tc39.es/ecma262/#sec-get-regexp-@@species\nsetSpecies('RegExp');\n","var isObject = require('../internals/is-object');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n","<template>\n  <base-modal @close-modal=\"toggleModal\" :open=\"true\">\n    <form\n      class=\"basic-form\"\n      @submit.prevent=\"submitCreds\"\n      novalidate\n    >\n      <h1 class=\"basic-form__header\">–†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø</h1>\n      <div\n        tabindex=\"0\"\n        id=\"googleBtn\"\n        class=\"customGPlusSignIn focus-ring\"\n      >\n        <span class=\"g-icon\"></span>\n        <span class=\"buttonText\">–í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Google</span>\n      </div>\n      <p>–∏–ª–∏</p>\n      <div class=\"basic-form__block\">\n        <label for=\"username\">–ü—Ä–∏–¥—É–º–∞–π—Ç–µ –∏–º—è</label>\n        <div class=\"checked-input\">\n          <span\n            v-if=\"isFree === false\"\n            class=\"checked-input__checker\"\n            >‚ùå</span\n          >\n          <span\n            v-else-if=\"isFree === true\"\n            class=\"checked-input__checker\"\n            >‚úÖ</span\n          >\n          <span\n            v-else-if=\"isApiCall\"\n            class=\"checked-input__checker\"\n            ><spinner></spinner\n          ></span>\n          <input\n            @change=\"checkUsername\"\n            type=\"text\"\n            id=\"username\"\n            v-model.trim.lazy=\"username\"\n          />\n        </div>\n        <span\n          v-if=\"\n            (!v$.username.required.$invalid &&\n              v$.username.isValid.$invalid) ||\n              v$.username.minLength.$invalid\n          \"\n          class=\"basic-form__error-msg\"\n          >–†–∞–∑—Ä–µ—à–µ–Ω—ã –±—É–∫–≤—ã –æ—Ç a-z, _ –∏ —Ç–æ—á–∫–∏. –ú–∏–Ω–∏–º—É–º 4\n          —Å–∏–º–≤–æ–ª–∞</span\n        >\n      </div>\n      <div class=\"basic-form__block\">\n        <label for=\"email\">–≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –ø–æ—á—Ç–∞</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          v-model.lazy.trim=\"email\"\n        />\n        <span\n          v-if=\"v$.email.email.$invalid\"\n          class=\"basic-form__error-msg\"\n          >–í–≤–µ–¥–∏—Ç –Ω–∞—Å—Ç–æ—è—â–∏–π –∏–º–µ–π–ª</span\n        >\n      </div>\n      <div class=\"basic-form__block\">\n        <label for=\"password\">–ü–∞—Ä–æ–ª—å</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          v-model.trim.lazy=\"password\"\n        />\n        <span\n          v-if=\"v$.password.minLength.$invalid\"\n          class=\"basic-form__error-msg\"\n          >–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤</span\n        >\n      </div>\n      <div class=\"basic-form__block\">\n        <label for=\"–°password\">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å</label>\n        <input\n          type=\"password\"\n          id=\"–°password\"\n          v-model.trim=\"Cpassword\"\n        />\n        <span\n          v-if=\"\n            v$.Cpassword.sameAs.$invalid &&\n              v$.Cpassword.required.$response\n          \"\n          class=\"basic-form__error-msg\"\n          >–ü–∞—Ä–æ–ª–∏ –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å</span\n        >\n      </div>\n\n      <p>–£–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã?</p>\n      <router-link\n        class=\"focus-ring\"\n        :to=\"{ name: 'LoginForm' }\"\n        >–í–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç</router-link\n      >\n      <base-button type=\"submit\" :isLoading=\"isApiCall\"\n        >–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</base-button\n      >\n    </form>\n  </base-modal>\n</template>\n\n<script>\nimport useVuelidate from '@vuelidate/core';\nimport {\n  required,\n  email,\n  sameAs,\n  minLength,\n} from '@vuelidate/validators';\nimport BaseButton from '@/components/UI/BaseButton.vue';\nimport showNotification from '../hooks/showNotification';\n\nconst regExp = new RegExp('^[a-z_.0-9]+$');\nconst isValid = (value) => regExp.test(value);\n\nexport default {\n  components: { BaseButton },\n  data() {\n    return {\n      email: '',\n      password: '',\n      Cpassword: '',\n      username: '',\n      v$: useVuelidate(),\n      isApiCall: false,\n      isFree: '',\n    };\n  },\n  computed: {},\n  methods: {\n    checkUsername() {\n      if (!this.username || this.v$.username.$invalid) {\n        this.isFree = '';\n        return;\n      }\n      if (!this.v$.username.$invalid) {\n        this.isApiCall = true;\n        this.$store\n          .dispatch('auth/checkUsername', this.username)\n          .then((res) => {\n            if (res.data.success) {\n              this.isFree = false;\n              showNotification('–¢–∞–∫–æ–µ –∏–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ ‚ùå');\n            } else {\n              this.isFree = true;\n            }\n          })\n          .catch(() => {\n            showNotification(\n              '–ß—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å –Ω–∞ –Ω–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ ü§¶‚Äç‚ôÇÔ∏è',\n            );\n          })\n          .finally(() => (this.isApiCall = false));\n      }\n    },\n    toggleModal() {\n      this.$router.push('/');\n    },\n    submitCreds() {\n      if (this.v$.$invalid || !this.isFree) {\n        showNotification('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ñ–æ—Ä–º—É –ø—Ä–∞–≤–∏–ª—å–Ω–æ üòï');\n        return;\n      }\n      this.isApiCall = true;\n      this.$store\n        .dispatch('auth/registerUser', {\n          email: this.email,\n          password: this.password,\n          username: this.username,\n        })\n        .then(() => {\n          showNotification('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å üéàüéàüéà');\n          this.$router.replace('/');\n        })\n        .catch((error) => {\n          if (error.response?.status === 400) {\n            showNotification('–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã  ‚úî');\n          } else {\n            showNotification(\n              '–ß—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å –Ω–∞ –Ω–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ ü§¶‚Äç‚ôÇÔ∏è',\n            );\n          }\n        })\n        .finally(() => (this.isApiCall = false));\n    },\n  },\n  mounted() {\n    /* eslint-disable no-undef */\n    window.googleUser = {};\n    gapi.load('auth2', () => {\n      const auth2 = gapi.auth2.init({\n        client_id:\n          '1011107927314-ql5jokbt0f5nktn3mtcnpr6daqj7qk9m.apps.googleusercontent.com',\n        cookiepolicy: 'single_host_origin',\n      });\n      const googleBtn = document.getElementById(\n        'googleBtn',\n      );\n      auth2.attachClickHandler(\n        googleBtn,\n        {},\n        (googleUser) => {\n          this.isApiCall = true;\n\n          const token = googleUser.getAuthResponse()\n            .id_token;\n          this.$store\n            .dispatch('auth/loginUser', { token })\n            .then(() => this.$router.replace('/'))\n            .catch(() => {\n              this.$store.dispatch(\n                'helpers/showNotification',\n                'Google –ø–æ–ª–æ–º–∞–ª—Å—è ü§¶‚Äç‚ôÇÔ∏è',\n              );\n            })\n            .finally(() => (this.isApiCall = false));\n        },\n      );\n    });\n  },\n  validations() {\n    return {\n      email: { required, email },\n      password: { required, minLength: minLength(6) },\n      Cpassword: {\n        required,\n        sameAs: sameAs(this.password),\n      },\n      username: {\n        required,\n        minLength: minLength(4),\n        isValid,\n      },\n    };\n  },\n};\n</script>\n","import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  isVue2,\n  isVue3,\n  install,\n}\n","import { isReactive, isReadonly, isRef, reactive, computed, watch, ref, nextTick, getCurrentInstance, isVue3, onBeforeMount, onBeforeUnmount, inject, provide } from 'vue-demi';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction unwrap(val) {\n  return isRef(val) ? val.value : val;\n}\nfunction unwrapObj(obj) {\n  var ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return Object.keys(obj).reduce(function (o, k) {\n    if (ignoreKeys.includes(k)) return o;\n    o[k] = unwrap(obj[k]);\n    return o;\n  }, {});\n}\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction _call(body, then, direct) {\n  if (direct) {\n    return then ? then(body()) : body();\n  }\n\n  try {\n    var result = Promise.resolve(body());\n    return then ? result.then(then) : result;\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\nvar ROOT_PATH = '__root';\n/**\n * @typedef {import('vue-demi').ComponentPublicInstance} VueInstance\n */\n\n/**\n * @typedef NormalizedValidator\n * @property {Validator} $validator\n * @property {String | Ref<String> | function(*): string} [$message]\n * @property {Object | Ref<Object>} [$params]\n * @property {Object | Ref<Object>} [$async]\n */\n\n/**\n * Response form a raw Validator function.\n * Should return a Boolean or an object with $invalid property.\n * @typedef {Boolean | { $valid: Boolean }} ValidatorResponse\n */\n\n/**\n * Raw validator function, before being normalized\n * Can return a Promise or a {@see ValidatorResponse}\n * @typedef {function(*): ((Promise<ValidatorResponse> | ValidatorResponse))} Validator\n */\n\n/**\n * Sorts the validators for a state tree branch\n * @param {Object<NormalizedValidator|Function>} validationsRaw\n * @return {{ rules: Object<NormalizedValidator>, nestedValidators: Object, config: Object }}\n */\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\n * Calls a validation rule by unwrapping it's value first from a ref.\n * @param {Validator} rule\n * @param {Ref} value\n * @param {VueInstance} instance\n * @return {Promise<ValidatorResponse> | ValidatorResponse}\n */\n\n\nfunction sortValidations() {\n  var validationsRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var validations = unwrap(validationsRaw);\n  var validationKeys = Object.keys(validations);\n  var rules = {};\n  var nestedValidators = {};\n  var config = {};\n  validationKeys.forEach(function (key) {\n    var v = validations[key];\n\n    switch (true) {\n      // If it is already normalized, use it\n      case isFunction(v.$validator):\n        rules[key] = v;\n        break;\n      // If it is just a function, normalize it first\n      // into { $validator: <Fun> }\n\n      case isFunction(v):\n        rules[key] = {\n          $validator: v\n        };\n        break;\n      // Catch $-prefixed properties as config\n\n      case key.startsWith('$'):\n        config[key] = v;\n        break;\n      // If it doesn‚Äôt match any of the above,\n      // treat as nestedValidators state property\n\n      default:\n        nestedValidators[key] = v;\n    }\n  });\n  return {\n    rules: rules,\n    nestedValidators: nestedValidators,\n    config: config\n  };\n}\n\nfunction callRule(rule, value, instance) {\n  var v = unwrap(value);\n  return rule.call(instance, v, instance);\n}\n/**\n * Normalizes the validator result\n * Allows passing a boolean of an object like `{ $valid: Boolean }`\n * @param {ValidatorResponse} result - Validator result\n * @return {Boolean}\n */\n\n\nfunction normalizeValidatorResponse(result) {\n  return result.$valid !== undefined ? !result.$valid : !result;\n}\n/**\n * Returns the result of an async validator.\n * @param {Function} rule\n * @param {Ref<*>} model\n * @param {Ref<Boolean>} $pending\n * @param {Ref<Boolean>} $dirty\n * @param {Object} config\n * @param {Ref<*>} $response\n * @param {VueInstance} instance\n * @return {Ref<Boolean>}\n */\n\n\nfunction createAsyncResult(rule, model, $pending, $dirty, _ref, $response, instance) {\n  var $lazy = _ref.$lazy;\n  var $invalid = ref(!!$dirty.value);\n  var $pendingCounter = ref(0);\n  $pending.value = false;\n  var $unwatch = watch([model, $dirty], function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        modelValue = _ref3[0],\n        dirty = _ref3[1];\n\n    if ($lazy && !$dirty.value) return false;\n    var ruleResult; // make sure we dont break if a validator throws\n\n    try {\n      ruleResult = callRule(rule, model, instance);\n    } catch (err) {\n      // convert to a promise, so we can handle it async\n      ruleResult = Promise.reject(err);\n    }\n\n    $pendingCounter.value++;\n    $pending.value = !!$pendingCounter.value;\n    $invalid.value = true;\n    Promise.resolve(ruleResult).then(function (data) {\n      $pendingCounter.value--;\n      $pending.value = !!$pendingCounter.value;\n      $response.value = data;\n      $invalid.value = normalizeValidatorResponse(data);\n    })[\"catch\"](function (error) {\n      $pendingCounter.value--;\n      $pending.value = !!$pendingCounter.value;\n      $response.value = error;\n      $invalid.value = true;\n    });\n  }, {\n    immediate: true,\n    deep: _typeof(model) === 'object'\n  });\n  return {\n    $invalid: $invalid,\n    $unwatch: $unwatch\n  };\n}\n/**\n * Returns the validation result.\n * Detects async and sync validators.\n * @param {NormalizedValidator} rule\n * @param {Ref<*>} model\n * @param {Ref<boolean>} $dirty\n * @param {Object} config\n * @param {VueInstance} instance\n * @return {{$params: *, $message: Ref<String>, $pending: Ref<Boolean>, $invalid: Ref<Boolean>, $response: Ref<*>}}\n */\n\n\nfunction createValidatorResult(rule, model, $dirty, config, instance) {\n  var $pending = ref(false);\n  var $params = rule.$params || {};\n  var $response = ref(null);\n\n  var _createAsyncResult = createAsyncResult(rule.$validator, model, $pending, $dirty, config, $response, instance),\n      $invalid = _createAsyncResult.$invalid,\n      $unwatch = _createAsyncResult.$unwatch;\n\n  var message = rule.$message;\n  var $message = isFunction(message) ? computed(function () {\n    return message(unwrapObj({\n      $pending: $pending,\n      $invalid: $invalid,\n      $params: unwrapObj($params),\n      // $params can hold refs, so we unwrap them for easy access\n      $model: model,\n      $response: $response\n    }));\n  }) : message || '';\n  return {\n    $message: $message,\n    $params: $params,\n    $pending: $pending,\n    $invalid: $invalid,\n    $response: $response,\n    $unwatch: $unwatch\n  };\n}\n/**\n * @typedef ErrorObject\n * @property {Ref<String>} $message - Reactive error message\n * @property {Ref<Object>} $params - Params passed from withParams\n * @property {Ref<Boolean>} $pending - If validation is pending\n * @property {String} $property - State key\n * @property {String} $propertyPath - Dot notation path to state\n * @property {String} $validator - Validator name\n */\n\n/**\n * @typedef ValidationResult\n * @property {Ref<Boolean>} $pending\n * @property {Ref<Boolean>} $dirty\n * @property {Ref<Boolean>} $invalid\n * @property {Ref<Boolean>} $error\n * @property {Ref<String>} $path\n * @property {Function} $touch\n * @property {Function} $reset\n * @property {ComputedRef<ErrorObject[]>} $errors\n * @property {ComputedRef<ErrorObject[]>} $silentErrors\n */\n\n/**\n * Creates the main Validation Results object for a state tree\n * Walks the tree's top level branches\n * @param {Object<NormalizedValidator>} rules - Rules for the current state tree\n * @param {Object} model - Current state value\n * @param {String} key - Key for the current state tree\n * @param {ResultsStorage} [resultsCache] - A cache map of all the validators\n * @param {String} [path] - the current property path\n * @param {Object} [config] - the config object\n * @param {VueInstance} instance\n * @return {ValidationResult | {}}\n */\n\n\nfunction createValidationResults(rules, model, key, resultsCache, path, config, instance) {\n  // collect the property keys\n  var ruleKeys = Object.keys(rules);\n  var cachedResult = resultsCache.get(path, rules);\n  var $dirty = ref(false);\n\n  if (cachedResult) {\n    // if the rules are the same as before, use the cached results\n    if (!cachedResult.$partial) return cachedResult; // remove old watchers\n\n    cachedResult.$unwatch(); // use the `$dirty.value`, so we dont save references by accident\n\n    $dirty.value = cachedResult.$dirty.value;\n  }\n\n  var result = {\n    // restore $dirty from cache\n    $dirty: $dirty,\n    $path: path,\n    $touch: function $touch() {\n      if (!$dirty.value) $dirty.value = true;\n    },\n    $reset: function $reset() {\n      if ($dirty.value) $dirty.value = false;\n    }\n  };\n  /**\n   * If there are no validation rules, it is most likely\n   * a top level state, aka root\n   */\n\n  if (!ruleKeys.length) {\n    // if there are cached results, we should overwrite them with the new ones\n    cachedResult && resultsCache.set(path, rules, result);\n    return result;\n  }\n\n  ruleKeys.forEach(function (ruleKey) {\n    result[ruleKey] = createValidatorResult(rules[ruleKey], model, result.$dirty, config, instance);\n  });\n  result.$invalid = computed(function () {\n    return ruleKeys.some(function (ruleKey) {\n      return unwrap(result[ruleKey].$invalid);\n    });\n  });\n  result.$pending = computed(function () {\n    return ruleKeys.some(function (ruleKey) {\n      return unwrap(result[ruleKey].$pending);\n    });\n  });\n  result.$error = computed(function () {\n    return result.$invalid.value && result.$dirty.value;\n  });\n  result.$silentErrors = computed(function () {\n    return ruleKeys.filter(function (ruleKey) {\n      return unwrap(result[ruleKey].$invalid);\n    }).map(function (ruleKey) {\n      var res = result[ruleKey];\n      return reactive({\n        $propertyPath: path,\n        $property: key,\n        $validator: ruleKey,\n        $message: res.$message,\n        $params: res.$params,\n        $response: res.$response,\n        $pending: res.$pending\n      });\n    });\n  });\n  result.$errors = computed(function () {\n    return result.$dirty.value ? result.$silentErrors.value : [];\n  });\n\n  result.$unwatch = function () {\n    return ruleKeys.forEach(function (ruleKey) {\n      result[ruleKey].$unwatch();\n    });\n  };\n\n  resultsCache.set(path, rules, result);\n  return result;\n}\n/**\n * Collects the validation results of all nested state properties\n * @param {Object<NormalizedValidator|Function>} validations - The validation\n * @param {Object} nestedState - Current state\n * @param {String} path - Path to current property\n * @param {ResultsStorage} resultsCache - Validations cache map\n * @param {Object} config - The config object\n * @return {{}}\n */\n\n\nfunction collectNestedValidationResults(validations, nestedState, path, resultsCache, config, instance) {\n  var nestedValidationKeys = Object.keys(validations); // if we have no state, return empty object\n\n  if (!nestedValidationKeys.length) return {};\n  return nestedValidationKeys.reduce(function (results, nestedKey) {\n    // build validation results for nested state\n    results[nestedKey] = setValidations({\n      validations: validations[nestedKey],\n      state: nestedState,\n      key: nestedKey,\n      parentKey: path,\n      resultsCache: resultsCache,\n      globalConfig: config,\n      instance: instance\n    });\n    return results;\n  }, {});\n}\n/**\n * Generates the Meta fields from the results\n * @param {ValidationResult|{}} results\n * @param {Object<ValidationResult>[]} nestedResults\n * @param {Object<ValidationResult>[]} childResults\n * @return {{$anyDirty: Ref<Boolean>, $error: Ref<Boolean>, $invalid: Ref<Boolean>, $errors: Ref<ErrorObject[]>, $dirty: Ref<Boolean>, $touch: Function, $reset: Function }}\n */\n\n\nfunction createMetaFields(results, nestedResults, childResults) {\n  var allResults = computed(function () {\n    return [nestedResults, childResults].filter(function (res) {\n      return res;\n    }).reduce(function (allRes, res) {\n      return allRes.concat(Object.values(unwrap(res)));\n    }, []);\n  }); // returns `$dirty` as true, if all children are dirty\n\n  var $dirty = computed({\n    get: function get() {\n      return results.$dirty.value || (allResults.value.length ? allResults.value.every(function (r) {\n        return r.$dirty;\n      }) : false);\n    },\n    set: function set(v) {\n      results.$dirty.value = v;\n    }\n  });\n  var $silentErrors = computed(function () {\n    // current state level errors, fallback to empty array if root\n    var modelErrors = unwrap(results.$silentErrors) || []; // collect all nested and child $silentErrors\n\n    var nestedErrors = allResults.value.filter(function (result) {\n      return (unwrap(result).$silentErrors || []).length;\n    }).reduce(function (errors, result) {\n      return errors.concat.apply(errors, _toConsumableArray(result.$silentErrors));\n    }, []); // merge the $silentErrors\n\n    return modelErrors.concat(nestedErrors);\n  });\n  var $errors = computed(function () {\n    // current state level errors, fallback to empty array if root\n    var modelErrors = unwrap(results.$errors) || []; // collect all nested and child $errors\n\n    var nestedErrors = allResults.value.filter(function (result) {\n      return (unwrap(result).$errors || []).length;\n    }).reduce(function (errors, result) {\n      return errors.concat.apply(errors, _toConsumableArray(result.$errors));\n    }, []); // merge the $errors\n\n    return modelErrors.concat(nestedErrors);\n  });\n  var $invalid = computed(function () {\n    return (// if any of the nested values is invalid\n      allResults.value.some(function (r) {\n        return r.$invalid;\n      }) || // or if the current state is invalid\n      unwrap(results.$invalid) || // fallback to false if is root\n      false\n    );\n  });\n  var $pending = computed(function () {\n    return (// if any of the nested values is pending\n      allResults.value.some(function (r) {\n        return unwrap(r.$pending);\n      }) || // if any of the current state validators is pending\n      unwrap(results.$pending) || // fallback to false if is root\n      false\n    );\n  });\n  var $anyDirty = computed(function () {\n    return allResults.value.some(function (r) {\n      return r.$dirty;\n    }) || allResults.value.some(function (r) {\n      return r.$anyDirty;\n    }) || $dirty.value;\n  });\n  var $error = computed(function () {\n    return $invalid.value && $dirty.value || false;\n  });\n\n  var $touch = function $touch() {\n    // call the root $touch\n    results.$touch(); // call all nested level $touch\n\n    allResults.value.forEach(function (result) {\n      result.$touch();\n    });\n  };\n\n  var $reset = function $reset() {\n    // reset the root $dirty state\n    results.$reset(); // reset all the children $dirty states\n\n    allResults.value.forEach(function (result) {\n      result.$reset();\n    });\n  }; // Ensure that if all child and nested results are $dirty, this also becomes $dirty\n\n\n  if (allResults.value.length && allResults.value.every(function (nr) {\n    return nr.$dirty;\n  })) $touch();\n  return {\n    $dirty: $dirty,\n    $errors: $errors,\n    $invalid: $invalid,\n    $anyDirty: $anyDirty,\n    $error: $error,\n    $pending: $pending,\n    $touch: $touch,\n    $reset: $reset,\n    $silentErrors: $silentErrors\n  };\n}\n/**\n * @typedef VuelidateState\n * @property {WritableComputedRef<any>} $model\n * @property {ComputedRef<Boolean>} $dirty\n * @property {ComputedRef<Boolean>} $error\n * @property {ComputedRef<ErrorObject[]>} $errors\n * @property {ComputedRef<Boolean>} $invalid\n * @property {ComputedRef<Boolean>} $anyDirty\n * @property {ComputedRef<Boolean>} $pending\n * @property {Function} $touch\n * @property {Function} $reset\n * @property {String} $path\n * @property {ComputedRef<ErrorObject[]>} $silentErrors\n * @property {Function} [$validate]\n * @property {Function} [$getResultsForChild]\n * @property {Object.<string, VuelidateState>}\n */\n\n/**\n * Main Vuelidate bootstrap function.\n * Used both for Composition API in `setup` and for Global App usage.\n * Used to collect validation state, when walking recursively down the state tree\n * @param {Object} params\n * @param {Object<NormalizedValidator|Function>} params.validations\n * @param {Object} params.state\n * @param {String} [params.key] - Current state property key. Used when being called on nested items\n * @param {String} [params.parentKey] - Parent state property key. Used when being called recursively\n * @param {Object<ValidationResult>} [params.childResults] - Used to collect child results.\n * @param {ResultsStorage} resultsCache - The cached validation results\n * @param {VueInstance} instance - The current Vue instance\n * @return {UnwrapNestedRefs<VuelidateState>}\n */\n\n\nfunction setValidations(_ref4) {\n  var validations = _ref4.validations,\n      state = _ref4.state,\n      key = _ref4.key,\n      parentKey = _ref4.parentKey,\n      childResults = _ref4.childResults,\n      resultsCache = _ref4.resultsCache,\n      _ref4$globalConfig = _ref4.globalConfig,\n      globalConfig = _ref4$globalConfig === void 0 ? {} : _ref4$globalConfig,\n      instance = _ref4.instance;\n  var path = parentKey ? \"\".concat(parentKey, \".\").concat(key) : key; // Sort out the validation object into:\n  // ‚Äì rules = validators for current state tree fragment\n  // ‚Äî nestedValidators = nested state fragments keys that might contain more validators\n  // ‚Äì config = configuration properties that affect this state fragment\n\n  var _sortValidations = sortValidations(validations),\n      rules = _sortValidations.rules,\n      nestedValidators = _sortValidations.nestedValidators,\n      config = _sortValidations.config;\n\n  var mergedConfig = Object.assign({}, globalConfig, config); // create protected state for cases when the state branch does not exist yet.\n  // This protects when using the OptionsAPI as the data is bound after the setup method\n\n  var nestedState = key ? computed(function () {\n    var s = unwrap(state);\n    return s ? unwrap(s[key]) : undefined;\n  }) : state; // Use rules for the current state fragment and validate it\n\n  var results = createValidationResults(rules, nestedState, key, resultsCache, path, mergedConfig, instance); // Use nested keys to repeat the process\n  // *WARN*: This is recursive\n\n  var nestedResults = collectNestedValidationResults(nestedValidators, nestedState, path, resultsCache, mergedConfig, instance); // Collect and merge this level validation results\n  // with all nested validation results\n\n  var _createMetaFields = createMetaFields(results, nestedResults, childResults),\n      $dirty = _createMetaFields.$dirty,\n      $errors = _createMetaFields.$errors,\n      $invalid = _createMetaFields.$invalid,\n      $anyDirty = _createMetaFields.$anyDirty,\n      $error = _createMetaFields.$error,\n      $pending = _createMetaFields.$pending,\n      $touch = _createMetaFields.$touch,\n      $reset = _createMetaFields.$reset,\n      $silentErrors = _createMetaFields.$silentErrors;\n  /**\n   * If we have no `key`, this is the top level state\n   * We dont need `$model` there.\n   */\n\n\n  var $model = key ? computed({\n    get: function get() {\n      return unwrap(nestedState);\n    },\n    set: function set(val) {\n      $dirty.value = true;\n      var s = unwrap(state);\n\n      if (isRef(s[key])) {\n        s[key].value = val;\n      } else {\n        s[key] = val;\n      }\n    }\n  }) : null;\n\n  if (key && mergedConfig.$autoDirty) {\n    var $unwatch = watch(nestedState, function () {\n      var autoDirtyPath = \"_\".concat(path, \"_$watcher_\");\n      var cachedAutoDirty = resultsCache.get(autoDirtyPath, {});\n      if (!$dirty.value) $touch();\n      if (cachedAutoDirty) cachedAutoDirty.$unwatch();\n      resultsCache.set(autoDirtyPath, {}, {\n        $unwatch: $unwatch\n      });\n    }, {\n      flush: 'sync'\n    });\n  }\n  /**\n   * Executes the validators and returns the result.\n   * @return {Promise<boolean>}\n   */\n\n\n  function $validate() {\n    return new Promise(_async(function (resolve) {\n      if (!$dirty.value) $touch(); // await the watchers\n\n      return _call(nextTick, function () {\n        // return whether it is valid or not\n        if (!$pending.value) return resolve(!$invalid.value);\n        var unwatch = watch($pending, function () {\n          resolve(!$invalid.value);\n          unwatch();\n        });\n      });\n    }));\n  }\n  /**\n   * Returns a child component's results, based on registration name\n   * @param {string} key\n   * @return {VuelidateState}\n   */\n\n\n  function $getResultsForChild(key) {\n    return (childResults.value || {})[key];\n  }\n\n  return reactive(Object.assign({}, results, {\n    // NOTE: The order here is very important, since we want to override\n    // some of the *results* meta fields with the collective version of it\n    // that includes the results of nested state validation results\n    $model: $model,\n    $dirty: $dirty,\n    $error: $error,\n    $errors: $errors,\n    $invalid: $invalid,\n    $anyDirty: $anyDirty,\n    $pending: $pending,\n    $touch: $touch,\n    $reset: $reset,\n    $path: path || ROOT_PATH,\n    $silentErrors: $silentErrors\n  }, childResults && {\n    $getResultsForChild: $getResultsForChild,\n    $validate: $validate\n  }, nestedResults));\n}\n\nvar ResultsStorage = /*#__PURE__*/function () {\n  function ResultsStorage() {\n    _classCallCheck(this, ResultsStorage);\n\n    this.storage = new Map();\n  }\n  /**\n   * Stores a validation result, and its rules by its path\n   * @param {String} path\n   * @param {Object<NormalizedValidator>} rules\n   * @param {ValidationResult} result\n   */\n\n\n  _createClass(ResultsStorage, [{\n    key: \"set\",\n    value: function set(path, rules, result) {\n      this.storage.set(path, {\n        rules: rules,\n        result: result\n      });\n    }\n    /**\n     * Check if the stored `results` for the provided `path` have the same `rules` compared to 'storedRules'\n     * @param {String} path\n     * @param {Object<NormalizedValidator>} rules\n     * @param {Object<NormalizedValidator>} storedRules\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"checkRulesValidity\",\n    value: function checkRulesValidity(path, rules, storedRules) {\n      var storedRulesKeys = Object.keys(storedRules);\n      var newRulesKeys = Object.keys(rules);\n      if (newRulesKeys.length !== storedRulesKeys.length) return false;\n      var hasAllValidators = newRulesKeys.every(function (ruleKey) {\n        return storedRulesKeys.includes(ruleKey);\n      });\n      if (!hasAllValidators) return false;\n      return newRulesKeys.every(function (ruleKey) {\n        if (!rules[ruleKey].$params) return true;\n        return Object.keys(rules[ruleKey].$params).every(function (paramKey) {\n          // make sure to unwrap before comparing\n          return unwrap(storedRules[ruleKey].$params[paramKey]) === unwrap(rules[ruleKey].$params[paramKey]);\n        });\n      });\n    }\n    /**\n     * Returns the matched result if catche is valid\n     * @param {String} path\n     * @param {Object<NormalizedValidator>} rules\n     * @return {{$partial: boolean, $dirty: Ref<boolean>}|undefined|ValidationResult}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(path, rules) {\n      var storedRuleResultPair = this.storage.get(path);\n      if (!storedRuleResultPair) return undefined;\n      var storedRules = storedRuleResultPair.rules,\n          result = storedRuleResultPair.result;\n      var isValidCache = this.checkRulesValidity(path, rules, storedRules);\n      var $unwatch = result.$unwatch ? result.$unwatch : function () {\n        return {};\n      };\n      if (!isValidCache) return {\n        $dirty: result.$dirty,\n        $partial: true,\n        $unwatch: $unwatch\n      };\n      return result;\n    }\n  }]);\n\n  return ResultsStorage;\n}();\n\nvar VuelidateInjectChildResults = Symbol('vuelidate#injectChiildResults');\nvar VuelidateRemoveChildResults = Symbol('vuelidate#removeChiildResults');\nvar CollectFlag = {\n  COLLECT_ALL: true,\n  COLLECT_NONE: false\n};\n/**\n * Create helpers to collect validation state from child components\n * @param {Object} params\n * @param {String | Number} params.$scope - Parent component scope\n * @return {{sendValidationResultsToParent: function, childResults: ComputedRef<Object>, removeValidationResultsFromParent: function}}\n */\n\nfunction nestedValidations(_ref) {\n  var $scope = _ref.$scope;\n  var childResultsRaw = {};\n  var childResultsKeys = ref([]);\n  var childResults = computed(function () {\n    return childResultsKeys.value.reduce(function (results, key) {\n      results[key] = unwrap(childResultsRaw[key]);\n      return results;\n    }, {});\n  });\n  /**\n   * Allows children to send validation data up to their parent.\n   * @param {Object} results - the results\n   * @param {Object} args\n   * @param {String} args.$registerAs - the $registeredAs key\n   * @param {String | Number} args.$scope - the $scope key\n   */\n\n  function injectChildResultsIntoParent(results, _ref2) {\n    var key = _ref2.$registerAs,\n        childScope = _ref2.$scope,\n        $stopPropagation = _ref2.$stopPropagation;\n    if ($stopPropagation || $scope === CollectFlag.COLLECT_NONE || childScope === CollectFlag.COLLECT_NONE || $scope !== CollectFlag.COLLECT_ALL && $scope !== childScope) return;\n    childResultsRaw[key] = results;\n    childResultsKeys.value.push(key);\n  }\n  /**\n   * Allows children to remove the validation data from their parent, before getting destroyed.\n   * @param {String} key - the registeredAs key\n   */\n\n\n  function removeChildResultsFromParent(key) {\n    // remove the key\n    childResultsKeys.value = childResultsKeys.value.filter(function (childKey) {\n      return childKey !== key;\n    }); // remove the stored data for the key\n\n    delete childResultsRaw[key];\n  } // inject the `injectChildResultsIntoParent` method, into the current scope\n\n\n  var sendValidationResultsToParent = inject(VuelidateInjectChildResults, function () {}); // provide to all of it's children the send results to parent function\n\n  provide(VuelidateInjectChildResults, injectChildResultsIntoParent);\n  var removeValidationResultsFromParent = inject(VuelidateRemoveChildResults, function () {}); // provide to all of it's children the remove results  function\n\n  provide(VuelidateRemoveChildResults, removeChildResultsFromParent);\n  return {\n    childResults: childResults,\n    sendValidationResultsToParent: sendValidationResultsToParent,\n    removeValidationResultsFromParent: removeValidationResultsFromParent\n  };\n}\n/**\n * @typedef GlobalConfig\n * @property {String} [$registerAs] - Config Object\n * @property {String | Number | Symbol} [$scope] - A scope to limit child component registration\n * @property {Boolean} [$stopPropagation] - Tells a Vue component to stop sending it's results up to the parent\n */\n\n/**\n * Composition API compatible Vuelidate\n * Use inside the `setup` lifecycle hook\n * @param {Object | GlobalConfig} [validations] - Validations Object or the globalConfig.\n * @param {Object} [state] - State object - required if `validations` is a validation object.\n * @param {GlobalConfig} [globalConfig] - Config Object\n * @return {UnwrapRef<*>}\n */\n\n\nfunction useVuelidate(validations, state) {\n  var globalConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // if we pass only one argument, its most probably the globalConfig.\n  // This use case is so parents can just collect results of child forms.\n  if (arguments.length === 1) {\n    globalConfig = validations;\n    validations = undefined;\n    state = undefined;\n  }\n\n  var _globalConfig = globalConfig,\n      $registerAs = _globalConfig.$registerAs,\n      _globalConfig$$scope = _globalConfig.$scope,\n      $scope = _globalConfig$$scope === void 0 ? CollectFlag.COLLECT_ALL : _globalConfig$$scope,\n      $stopPropagation = _globalConfig.$stopPropagation;\n  var instance = getCurrentInstance();\n  var componentOptions = instance ? isVue3 ? instance.type : instance.proxy.$options : {}; // if there is no registration name, add one.\n\n  if (!$registerAs && instance) {\n    // NOTE:\n    // ._uid // Vue 2.x Composition-API plugin\n    // .uid // Vue 3.0\n    var uid = instance.uid || instance._uid;\n    $registerAs = \"_vuelidate_\".concat(uid);\n  }\n\n  var validationResults = ref({});\n  var resultsCache = new ResultsStorage();\n\n  var _ref3 = instance ? nestedValidations({\n    $scope: $scope\n  }) : {\n    childResults: ref({})\n  },\n      childResults = _ref3.childResults,\n      sendValidationResultsToParent = _ref3.sendValidationResultsToParent,\n      removeValidationResultsFromParent = _ref3.removeValidationResultsFromParent; // Options API\n\n\n  if (!validations && componentOptions.validations) {\n    var rules = componentOptions.validations;\n    state = ref({});\n    onBeforeMount(function () {\n      // Delay binding state to validations defined with the Options API until mounting, when the data\n      // has been attached to the component instance. From that point on it will be reactive.\n      state.value = instance.proxy; // helper proxy for instance property access. It makes every reference\n      // reactive for the validation function\n\n      function ComputedProxyFactory(target) {\n        return new Proxy(target, {\n          get: function get(target, prop, receiver) {\n            return _typeof(target[prop]) === 'object' ? ComputedProxyFactory(target[prop]) : computed(function () {\n              return target[prop];\n            });\n          }\n        });\n      }\n\n      watch(function () {\n        return isFunction(rules) ? rules.call(state.value, new ComputedProxyFactory(state.value)) : rules;\n      }, function (validations) {\n        validationResults.value = setValidations({\n          validations: validations,\n          state: state,\n          childResults: childResults,\n          resultsCache: resultsCache,\n          globalConfig: globalConfig,\n          instance: instance.proxy\n        });\n      }, {\n        immediate: true\n      });\n    });\n    globalConfig = componentOptions.validationsConfig || {};\n  } else {\n    var validationsWatchTarget = isRef(validations) || isProxy(validations) ? validations // wrap plain objects in a reactive, so we can track changes if they have computed in them.\n    : reactive(validations || {});\n    watch(validationsWatchTarget, function (newValidationRules) {\n      validationResults.value = setValidations({\n        validations: newValidationRules,\n        state: state,\n        childResults: childResults,\n        resultsCache: resultsCache,\n        globalConfig: globalConfig,\n        instance: instance ? instance.proxy : {}\n      });\n    }, {\n      immediate: true\n    });\n  }\n\n  if (instance) {\n    // send all the data to the parent when the function is invoked inside setup.\n    sendValidationResultsToParent(validationResults, {\n      $registerAs: $registerAs,\n      $scope: $scope,\n      $stopPropagation: $stopPropagation\n    }); // before this component is destroyed, remove all the data from the parent.\n\n    onBeforeUnmount(function () {\n      return removeValidationResultsFromParent($registerAs);\n    });\n  } // TODO: Change into reactive + watch\n\n\n  return computed(function () {\n    return Object.assign({}, unwrap(validationResults.value), childResults.value);\n  });\n}\n\nexport default useVuelidate;\nexport { CollectFlag, useVuelidate };\n","import { unref } from 'vue-demi';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isObject(o) {\n  return o !== null && _typeof(o) === 'object' && !Array.isArray(o);\n}\n/**\n * Returns a standard ValidatorObject\n * Wraps a plain function into a ValidatorObject\n * @param {NormalizedValidator|Function} validator\n * @return {NormalizedValidator}\n */\n\nfunction normalizeValidatorObject(validator) {\n  return isFunction(validator.$validator) ? validator : {\n    $validator: validator\n  };\n}\n/**\n * Unwraps a ValidatorResponse object, into a boolean.\n * @param {ValidatorResponse} result\n * @return {boolean}\n */\n\nfunction unwrapValidatorResponse(result) {\n  if (_typeof(result) === 'object') return result.$valid;\n  return result;\n}\n/**\n * Unwraps a `NormalizedValidator` object, returning it's validator function.\n * @param {NormalizedValidator | Function} validator\n * @return {function}\n */\n\nfunction unwrapNormalizedValidator(validator) {\n  return validator.$validator || validator;\n}\n\n/**\n * Allows attaching parameters to a validator\n * @param {Object} $params\n * @param {NormalizedValidator|Function} $validator\n * @return {NormalizedValidator}\n */\n\nfunction withParams($params, $validator) {\n  if (!isObject($params)) throw new Error(\"[@vuelidate/validators]: First parameter to \\\"withParams\\\" should be an object, provided \".concat(_typeof($params)));\n  if (!isObject($validator) && !isFunction($validator)) throw new Error(\"[@vuelidate/validators]: Validator must be a function or object with $validator parameter\");\n  var validatorObj = normalizeValidatorObject($validator);\n  validatorObj.$params = Object.assign({}, validatorObj.$params, $params);\n  return validatorObj;\n}\n\n/**\n * @callback MessageCallback\n * @param {Object} params\n * @return String\n */\n\n/**\n * Attaches a message to a validator\n * @param {MessageCallback | String} $message\n * @param {NormalizedValidator|Function} $validator\n * @return {NormalizedValidator}\n */\n\nfunction withMessage($message, $validator) {\n  if (!isFunction($message) && typeof unref($message) !== 'string') throw new Error(\"[@vuelidate/validators]: First parameter to \\\"withMessage\\\" should be string or a function returning a string, provided \".concat(_typeof($message)));\n  if (!isObject($validator) && !isFunction($validator)) throw new Error(\"[@vuelidate/validators]: Validator must be a function or object with $validator parameter\");\n  var validatorObj = Object.assign({}, normalizeValidatorObject($validator));\n  validatorObj.$message = $message;\n  return validatorObj;\n}\n\nvar req = function req(value) {\n  value = unref(value);\n  if (Array.isArray(value)) return !!value.length;\n\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  if (value === false) {\n    return true;\n  }\n\n  if (value instanceof Date) {\n    // invalid date won't pass\n    return !isNaN(value.getTime());\n  }\n\n  if (_typeof(value) === 'object') {\n    for (var _ in value) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return !!String(value).length;\n};\n/**\n * Returns the length of an arbitrary value\n * @param {Array|Object|String} value\n * @return {number}\n */\n\nvar len = function len(value) {\n  value = unref(value);\n  if (Array.isArray(value)) return value.length;\n\n  if (_typeof(value) === 'object') {\n    return Object.keys(value).length;\n  }\n\n  return String(value).length;\n};\n/**\n * Regex based validator template\n * @param {RegExp} expr\n * @return {function(*=): boolean}\n */\n\nfunction regex(expr) {\n  return function (value) {\n    value = unref(value);\n    return !req(value) || expr.test(value);\n  };\n}\n\n\n\nvar common = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  withParams: withParams,\n  withMessage: withMessage,\n  req: req,\n  len: len,\n  regex: regex,\n  unwrap: unref\n});\n\nvar alpha = regex(/^[a-zA-Z]*$/);\n\n/**\n * Validate if value is alphabetical string.\n * @type {NormalizedValidator}\n */\n\nvar alpha$1 = {\n  $validator: alpha,\n  $message: 'The value is not alphabetical'\n};\n\nvar alphaNum = regex(/^[a-zA-Z0-9]*$/);\n\n/**\n * Validate if value is alpha-numeric string.\n * @type {NormalizedValidator}\n */\n\nvar alphaNum$1 = {\n  $validator: alphaNum,\n  $message: 'The value must be alpha-numeric'\n};\n\nvar numeric = regex(/^\\d*(\\.\\d+)?$/);\n\n/**\n * Check whether a value is numeric.\n * @type NormalizedValidator\n */\n\nvar numeric$1 = {\n  $validator: numeric,\n  $message: 'Value must be numeric'\n};\n\n/**\n * Check if a numeric value is between two values.\n * @param {Ref<Number> | Number} min\n * @param {Ref<Number> | Number} max\n * @return {function(*=): boolean}\n */\n\nfunction between (min, max) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +unref(min) <= +value && +unref(max) >= +value;\n  };\n}\n\n/**\n * Checks if a value is between two values.\n * @param {Ref<Number> | Number} min\n * @param {Ref<Number> | Number} max\n * @return {NormalizedValidator}\n */\n\nfunction between$1 (min, max) {\n  return {\n    $validator: between(min, max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The value must be between \".concat($params.min, \" and \").concat($params.max);\n    },\n    $params: {\n      min: min,\n      max: max\n    }\n  };\n}\n\nvar emailRegex = /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/;\nvar email = regex(emailRegex);\n\n/**\n * Validate if value is an email.\n * @type {NormalizedValidator}\n */\n\nvar email$1 = {\n  $validator: email,\n  $message: 'Value is not a valid email address'\n};\n\n/**\n * Check if a string is an IP Address\n * @param {String} value\n * @returns {boolean}\n */\n\nfunction ipAddress (value) {\n  if (!req(value)) {\n    return true;\n  }\n\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  var nibbles = value.split('.');\n  return nibbles.length === 4 && nibbles.every(nibbleValid);\n}\n\nvar nibbleValid = function nibbleValid(nibble) {\n  if (nibble.length > 3 || nibble.length === 0) {\n    return false;\n  }\n\n  if (nibble[0] === '0' && nibble !== '0') {\n    return false;\n  }\n\n  if (!nibble.match(/^\\d+$/)) {\n    return false;\n  }\n\n  var numeric = +nibble | 0;\n  return numeric >= 0 && numeric <= 255;\n};\n\n/**\n * Validate if value is an ipAddress string.\n * @type {NormalizedValidator}\n */\n\nvar ipAddress$1 = {\n  $validator: ipAddress,\n  $message: 'The value is not a valid IP address'\n};\n\n/**\n * Check if value is a properly formatted Mac Address.\n * @param {String | Ref<String>} [separator]\n * @returns {function(*): boolean}\n */\n\nfunction macAddress () {\n  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':';\n  return function (value) {\n    separator = unref(separator);\n\n    if (!req(value)) {\n      return true;\n    }\n\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    var parts = typeof separator === 'string' && separator !== '' ? value.split(separator) : value.length === 12 || value.length === 16 ? value.match(/.{2}/g) : null;\n    return parts !== null && (parts.length === 6 || parts.length === 8) && parts.every(hexValid);\n  };\n}\n\nvar hexValid = function hexValid(hex) {\n  return hex.toLowerCase().match(/^[0-9a-f]{2}$/);\n};\n\n/**\n * Validate if value is a valid Mac Address string.\n * @returns {NormalizedValidator}\n */\n\nfunction macAddress$1 (separator) {\n  return {\n    $validator: macAddress(separator),\n    $message: 'The value is not a valid MAC Address'\n  };\n}\n\n/**\n * Check if provided value has a maximum length\n * @param {Number | Ref<Number>} length\n * @returns {function(Array|Object|String): boolean}\n */\n\nfunction maxLength (length) {\n  return function (value) {\n    return !req(value) || len(value) <= unref(length);\n  };\n}\n\n/**\n * Validate the max length of a string.\n * @param {Number} max\n * @return {NormalizedValidator}\n */\n\nfunction maxLength$1 (max) {\n  return {\n    $validator: maxLength(max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The maximum length allowed is \".concat($params.max);\n    },\n    $params: {\n      max: max\n    }\n  };\n}\n\n/**\n * Check if value is above a threshold.\n * @param {Number | Ref<Number>} length\n * @returns {function(Array|Object|String): boolean}\n */\n\nfunction minLength (length) {\n  return function (value) {\n    return !req(value) || len(value) >= unref(length);\n  };\n}\n\n/**\n * Check if value is above a threshold.\n * @param {Number | Ref<Number>} min\n * @returns {NormalizedValidator}\n */\n\nfunction minLength$1 (min) {\n  return {\n    $validator: minLength(min),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"This field should be at least \".concat($params.min, \" long\");\n    },\n    $params: {\n      min: min\n    }\n  };\n}\n\n/**\n * Validates if a value is empty.\n * @param {String | Array | Date | Object} value\n * @returns {boolean}\n */\n\nfunction required (value) {\n  if (typeof value === 'string') {\n    value = value.trim();\n  }\n\n  return req(value);\n}\n\n/**\n * Check if a value is empty or not.\n * @type {NormalizedValidator}\n */\n\nvar required$1 = {\n  $validator: required,\n  $message: 'Value is required'\n};\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar validate = function validate(prop, val) {\n  return prop ? req(val) : true;\n};\n/**\n * Returns required if the passed property is truthy\n * @param {Boolean | String | function(any): (Boolean | Promise<boolean>)} propOrFunction\n * @return {function(*): (Boolean | Promise<Boolean>)}\n */\n\n\nfunction requiredIf(propOrFunction) {\n  return function requiredIfInternal(value, parentVM) {\n    try {\n      var _this2 = this;\n\n      if (typeof propOrFunction !== 'function') {\n        return validate(propOrFunction, value);\n      }\n\n      return _await(propOrFunction.call(_this2, value, parentVM), function (result) {\n        return validate(result, value);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n/**\n * Returns required if the passed property is truthy\n * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop\n * @return {NormalizedValidator}\n */\n\nfunction requiredIf$1 (prop) {\n  return {\n    $validator: requiredIf(prop),\n    $message: 'The value is required'\n  };\n}\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar validate$1 = function validate(prop, val) {\n  return !prop ? req(val) : true;\n};\n/**\n * Returns required if the passed property is falsy.\n * @param {Boolean | String | function(any): (Boolean | Promise<boolean>)} propOrFunction\n * @return {function(*): (Boolean | Promise<Boolean>)}\n */\n\n\nfunction requiredUnless(propOrFunction) {\n  return function requiredUnlessInternal(value, parentVM) {\n    try {\n      var _this2 = this;\n\n      if (typeof propOrFunction !== 'function') {\n        return validate$1(propOrFunction, value);\n      }\n\n      return _await$1(propOrFunction.call(_this2, value, parentVM), function (result) {\n        return validate$1(result, value);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n/**\n * Returns required unless the passed property is truthy\n * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop\n * @return {NormalizedValidator}\n */\n\nvar requiredUnless$1 = (function (prop) {\n  return {\n    $validator: requiredUnless(prop),\n    $message: 'The value is required'\n  };\n});\n\n/**\n * Check if two values are identical.\n * @param {*} equalTo\n * @return {function(*=): boolean}\n */\n\nfunction sameAs (equalTo) {\n  return function (value) {\n    return unref(value) === unref(equalTo);\n  };\n}\n\n/**\n * Check if two values are identical\n * @param {*} equalTo\n * @param {String} [otherName]\n * @return {NormalizedValidator}\n */\n\nfunction sameAs$1 (equalTo) {\n  var otherName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'other';\n  return {\n    $validator: sameAs(equalTo),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The value must be equal to the \".concat(otherName, \" value\");\n    },\n    $params: {\n      equalTo: equalTo,\n      otherName: otherName\n    }\n  };\n}\n\nvar urlRegex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i;\nvar url = regex(urlRegex);\n\n/**\n * Check if a value is a url\n * @type {NormalizedValidator}\n */\n\nvar url$1 = {\n  $validator: url,\n  $message: 'The value is not a valid URL address'\n};\n\n/**\n * Returns true when one of the provided functions returns true.\n * @param {...(NormalizedValidator|Function)} validators\n * @return {function(...[*]=): boolean}\n */\n\nfunction _await$2(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction or() {\n  for (var _len = arguments.length, validators = new Array(_len), _key = 0; _key < _len; _key++) {\n    validators[_key] = arguments[_key];\n  }\n\n  return function orInternal() {\n    var _this = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return validators.length > 0 && validators.reduce(function (valid, fn) {\n      return _await$2(valid, function (_valid) {\n        return _await$2(_valid || unwrapNormalizedValidator(fn).apply(_this, args), function (_unwrapNormalizedVali) {\n          return _valid || unwrapValidatorResponse(_unwrapNormalizedVali);\n        }, _valid);\n      });\n    }, Promise.resolve(false));\n  };\n}\n\n/**\n * Returns true when one of the provided functions returns true.\n * @param {...(NormalizedValidator|Function)} validators\n * @return {NormalizedValidator}\n */\n\nfunction or$1 () {\n  return {\n    $validator: or.apply(void 0, arguments),\n    $message: 'The value does not match any of the provided validators'\n  };\n}\n\n/**\n * Returns true when all validators are truthy\n * @param {...(NormalizedValidator | Function | function(): Promise<boolean>)} validators\n * @return {function(...[*]=): boolean}\n */\n\nfunction _await$3(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction and() {\n  for (var _len = arguments.length, validators = new Array(_len), _key = 0; _key < _len; _key++) {\n    validators[_key] = arguments[_key];\n  }\n\n  return function andInternal() {\n    var _this = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return validators.length > 0 && validators.reduce(function (valid, fn) {\n      return _await$3(valid, function (_valid) {\n        return _await$3(_valid && unwrapNormalizedValidator(fn).apply(_this, args), function (_unwrapNormalizedVali) {\n          return _valid && unwrapValidatorResponse(_unwrapNormalizedVali);\n        }, !_valid);\n      });\n    }, Promise.resolve(true));\n  };\n}\n\n/**\n * Validate if all validators match.\n * @param {...*} validators\n * @returns {NormalizedValidator}\n */\n\nfunction and$1 () {\n  return {\n    $validator: and.apply(void 0, arguments),\n    $message: 'The value does not match all of the provided validators'\n  };\n}\n\n/**\n * Swaps the result of a value\n * @param {NormalizedValidator|Function} validator\n * @returns {function(*=, *=): boolean}\n */\n\nfunction _await$4(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction not (validator) {\n  return _async(function (value, vm) {\n    var _this = this;\n\n    var _req = !req(value);\n\n    return _await$4(_req || unwrapNormalizedValidator(validator).call(_this, value, vm), function (_unwrapNormalizedVali) {\n      return _req || !unwrapValidatorResponse(_unwrapNormalizedVali);\n    }, _req);\n  });\n}\n\n/**\n * Swaps the result of a value\n * @param {NormalizedValidator|Function} validator\n * @returns {NormalizedValidator}\n */\n\nfunction not$1 (validator) {\n  return {\n    $validator: not(validator),\n    $message: \"The value does not match the provided validator\"\n  };\n}\n\n/**\n * Check if a value is above a threshold.\n * @param {String | Number | Ref<Number> | Ref<String>} min\n * @returns {function(*=): boolean}\n */\n\nfunction minValue (min) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +value >= +unref(min);\n  };\n}\n\n/**\n * Check if a value is above a threshold.\n * @param {String | Number | Ref<Number> | Ref<String>} min\n * @returns {NormalizedValidator}\n */\n\nfunction minValue$1 (min) {\n  return {\n    $validator: minValue(min),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The minimum value allowed is \".concat($params.min);\n    },\n    $params: {\n      min: min\n    }\n  };\n}\n\n/**\n * Check if value is below a threshold.\n * @param {Number | Ref<Number> | Ref<String>} max\n * @returns {function(*=): boolean}\n */\n\nfunction maxValue (max) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +value <= +unref(max);\n  };\n}\n\n/**\n * Check if value is below a threshold.\n * @param {Number | Ref<Number> | Ref<String>} max\n * @return {NormalizedValidator}\n */\n\nvar maxValue$1 = (function (max) {\n  return {\n    $validator: maxValue(max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The maximum value is \".concat($params.max);\n    },\n    $params: {\n      max: max\n    }\n  };\n});\n\n// ^-[0-9]+$ - only for negative integer (minus sign without at least 1 digit is not a number)\n\nvar integer = regex(/(^[0-9]*$)|(^-[0-9]+$)/);\n\n/**\n * Validate if value is integer.\n * @type {NormalizedValidator}\n */\n\nvar integer$1 = {\n  $validator: integer,\n  $message: 'Value is not an integer'\n};\n\nvar decimal = regex(/^[-]?\\d*(\\.\\d+)?$/);\n\n/**\n * Validate if value is decimal number.\n * @type {NormalizedValidator}\n */\n\nvar decimal$1 = {\n  $validator: decimal,\n  $message: 'Value must be decimal'\n};\n\nexport { alpha$1 as alpha, alphaNum$1 as alphaNum, and$1 as and, between$1 as between, decimal$1 as decimal, email$1 as email, common as helpers, integer$1 as integer, ipAddress$1 as ipAddress, macAddress$1 as macAddress, maxLength$1 as maxLength, maxValue$1 as maxValue, minLength$1 as minLength, minValue$1 as minValue, not$1 as not, numeric$1 as numeric, or$1 as or, required$1 as required, requiredIf$1 as requiredIf, requiredUnless$1 as requiredUnless, sameAs$1 as sameAs, url$1 as url };\n","import { render } from \"./RegisterForm.vue?vue&type=template&id=91968aa8\"\nimport script from \"./RegisterForm.vue?vue&type=script&lang=js\"\nexport * from \"./RegisterForm.vue?vue&type=script&lang=js\"\nscript.render = render\n\nexport default script"],"sourceRoot":""}